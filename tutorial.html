<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorial - Zngur</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Zngur</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/hkalbasi/zngur" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>A Zngur project consists of 3 things:</p>
<ul>
<li>An IDL (interface definition language) file named <code>main.zng</code></li>
<li>A Rust crate (that can be anything: binary, rlib, static-lib, cdy-lib, ...)</li>
<li>A C++ project.</li>
</ul>
<p>To start, install Zngur:</p>
<pre><code>cargo install zngur-cli
</code></pre>
<p>Then generate a new <code>staticlib</code> crate using <code>cargo init --lib</code>
and by appending this to <code>Cargo.toml</code>:</p>
<pre><code class="language-Toml">[lib]
crate-type = ["staticlib"]
</code></pre>
<p>And create an empty <code>main.cpp</code> and <code>main.zng</code> file.
Your directory tree should look like this:</p>
<pre><code>├── Cargo.toml
├── main.cpp
├── main.zng
└── src
    └── lib.rs
</code></pre>
<h2 id="basic-structure-of-mainzng"><a class="header" href="#basic-structure-of-mainzng">Basic structure of <code>main.zng</code></a></h2>
<p>Imagine we want to use this inventory in C++:</p>
<pre><code class="language-Rust">struct Item {
    name: String,
    size: u32,
}

struct Inventory {
    items: Vec&lt;Item&gt;,
    remaining_space: u32,
}

impl Inventory {
    fn new_empty(space: u32) -&gt; Self {
        Self {
            items: vec![],
            remaining_space: space,
        }
    }
}
</code></pre>
<p>Copy it into <code>src/lib.rs</code>.
Now we need to declare things that we need to access in C++ in the <code>main.zng</code> file:</p>
<pre><code>type crate::Inventory {
    #layout(size = 32, align = 8);

    fn new_empty(u32) -&gt; crate::Inventory;
}
</code></pre>
<p>Zngur needs to know the size and alignment of the types inside the bridge.
You can find these using rust-analyzer (by hovering over the struct or type alias)
or fill it with some random number and then fix it from the compiler error.</p>
<blockquote>
<p><strong>Note:</strong> Ideally <code>main.zng</code> should be auto-generated, but we are not there yet.
Also, Zngur can work without explicit size and alignment (with some caveats),
see <a href="./call_rust_from_cpp/layout_policy.html">layout policies</a> for more details.</p>
</blockquote>
<p>Now, run <code>zngur g ./main.zng</code> to generate the C++ and Rust glue files.
It will generate a <code>./generated.h</code> C++ header file, and a <code>./src/generated.rs</code> file.
Add a <code>mod generated;</code> to your <code>lib.rs</code> file to include the generated Rust file.
Then fill <code>main.cpp</code> file with the following content:</p>
<pre><code class="language-C++">#include "./generated.h"

int main() {
  auto inventory = rust::crate::Inventory::new_empty(1000);
}
</code></pre>
<p>Zngur will add every Rust item with its full path in the <code>rust</code> namespace,
so for example <code>String</code> will become <code>rust::std::string::String</code> in the C++ side.</p>
<p>To build it, you first need to build the Rust code using <code>cargo build</code>,
which will generate a <code>libyourcrate.a</code> in the <code>./target/debug</code> folder,
and then you can build your C++ code by linking to it:</p>
<pre><code class="language-bash">clang++ main.cpp -g -L ./target/debug/ -l your_crate
</code></pre>
<p>To ensure that everything works,
let's add a <code>#[derive(Debug)]</code> to <code>Inventory</code> and use <code>zngur_dbg</code> to see it:</p>
<pre><code>type crate::Inventory {
    #layout(size = 32, align = 8);
    wellknown_traits(Debug);

    fn new_empty(u32) -&gt; crate::Inventory;
}
</code></pre>
<pre><code class="language-C++">int main() {
  auto inventory = rust::crate::Inventory::new_empty(1000);
  zngur_dbg(inventory);
}
</code></pre>
<p>There are some traits that Zngur has special support for them, and <code>Debug</code> is among them.
<a href="./call_rust_from_cpp/wellknown_traits.html">This page</a> has the complete list of them.</p>
<p>Assuming that everything works correctly,
you should see something like this after executing the program:</p>
<pre><code>[main.cpp:5] inventory = Inventory {
    items: [],
    remaining_space: 1000,
}
</code></pre>
<p>Now let's add some more methods to it:</p>
<pre><code class="language-Rust">impl Inventory {
    fn add_item(&amp;mut self, item: Item) {
        self.remaining_space -= item.size;
        self.items.push(item);
    }

    fn add_banana(&amp;mut self, count: u32) {
        for _ in 0..count {
            self.add_item(Item {
                name: "banana".to_owned(),
                size: 7,
            });
        }
    }
}
</code></pre>
<pre><code>type crate::Inventory {
    #layout(size = 32, align = 8);
    wellknown_traits(Debug);

    fn new_empty(u32) -&gt; crate::Inventory;
    fn add_banana(&amp;mut self, u32);
}
</code></pre>
<p>Now we can use it in the C++ file:</p>
<pre><code class="language-C++">#include "./generated.h"

int main() {
  auto inventory = rust::crate::Inventory::new_empty(1000);
  inventory.add_banana(3);
  zngur_dbg(inventory);
}
</code></pre>
<pre><code>[main.cpp:6] inventory = Inventory {
    items: [
        Item {
            name: "banana",
            size: 7,
        },
        Item {
            name: "banana",
            size: 7,
        },
        Item {
            name: "banana",
            size: 7,
        },
    ],
    remaining_space: 979,
}
</code></pre>
<p>Bridging the <code>add_item</code> method requires a little more effort.
We need to declare <code>crate::Item</code> type as well since it is an argument of that function:</p>
<pre><code>// ...

type crate::Item {
    #layout(size = 32, align = 8);
}

type crate::Inventory {
    // ...
    fn add_item(&amp;mut self, crate::Item);
}
</code></pre>
<p>But using that alone we can't use the <code>add_item</code>
since there is no way to obtain a <code>rust::crate::Item</code> in the C++ side.
To fix that, we need to add the constructor for the <code>Item</code>:</p>
<pre><code>type ::std::string::String {
    #layout(size = 24, align = 8);
}

type crate::Item {
    #layout(size = 32, align = 8);

    constructor { name: ::std::string::String, size: u32 };
}
</code></pre>
<p>But it doesn't solve the problem, since we can't create a <code>String</code> so we can't call the constructor.
To creating a <code>String</code>, we declare the primitive type <code>str</code> and its <code>to_owned</code> method:</p>
<pre><code>type str {
    wellknown_traits(?Sized);

    fn to_owned(&amp;self) -&gt; ::std::string::String;
}
</code></pre>
<p>There are some new things here.
First, since <code>str</code> is a primitive it doesn't need full path.
Then there is <code>wellknown_traits(?Sized)</code> instead of <code>#layout(size = X, align = Y)</code>
which tells Zngur that this type is unsized and it should consider its references as fat
and prevent storing it by value.</p>
<p>Now you may wonder how we can obtain a <code>&amp;str</code> to make a <code>String</code> from it?
Fortunately, Zngur has some special support for primitive types
and it has a <code>operator""_rs</code> that creates a <code>&amp;str</code> from a zero terminated, valid UTF8 <code>char*</code> with the static lifetime.
If Zngur didn't have this, we could create a <code>&amp;[u8]</code> by exporting its <code>from_raw_parts</code> and then converting it to a <code>&amp;str</code>,
but Zngur tries to mimic Rust language features in C++ with a similar syntax.</p>
<p>So now we can finally use the <code>add_item</code> method:</p>
<pre><code class="language-C++">int main() {
  auto inventory = rust::crate::Inventory::new_empty(1000);
  inventory.add_banana(3);
  inventory.add_item(rust::crate::Item("apple"_rs.to_owned(), 5));
  zngur_dbg(inventory);
}
</code></pre>
<pre><code>[main.cpp:8] inventory = Inventory {
    items: [
        Item {
            name: "banana",
            size: 7,
        },
        Item {
            name: "banana",
            size: 7,
        },
        Item {
            name: "banana",
            size: 7,
        },
        Item {
            name: "apple",
            size: 5,
        },
    ],
    remaining_space: 974,
}
</code></pre>
<h2 id="generic-types"><a class="header" href="#generic-types">Generic types</a></h2>
<p>Let's try to add and bridge the <code>into_items</code> method:</p>
<pre><code class="language-Rust">impl Inventory {
    fn into_items(self) -&gt; Vec&lt;Item&gt; {
        self.items
    }
}
</code></pre>
<p><code>Vec</code> is a generic type, but the syntax to use it is not different:</p>
<pre><code>type ::std::vec::Vec&lt;crate::Item&gt; {
    #layout(size = 24, align = 8);
    wellknown_traits(Debug);
}

type crate::Inventory {
    // ...
    fn into_items(self) -&gt; ::std::vec::Vec&lt;crate::Item&gt;;
}
</code></pre>
<p>Note that this only brings <code>Vec&lt;Item&gt;</code>,
for using <code>Vec&lt;i32&gt;</code> or <code>Vec&lt;String&gt;</code> or <code>Vec&lt;SomethingElse&gt;</code> you need to add each of them separately.</p>
<p>Now you can use <code>into_items</code> method in C++:</p>
<pre><code class="language-C++">rust::std::vec::Vec&lt;rust::crate::Item&gt; v = inventory.into_items();
zngur_dbg(v);
</code></pre>
<pre><code>[main.cpp:11] v = [
    Item {
        name: "banana",
        size: 7,
    },
    Item {
        name: "banana",
        size: 7,
    },
    Item {
        name: "banana",
        size: 7,
    },
    Item {
        name: "apple",
        size: 5,
    },
]
</code></pre>
<p>You can see the full code at <a href="https://github.com/HKalbasi/zngur/blob/main/examples/tutorial"><code>examples/tutorial</code></a></p>
<h2 id="calling-c-from-rust"><a class="header" href="#calling-c-from-rust">Calling C++ from Rust</a></h2>
<p>C++/Rust interop has two sides, and no interop tool is complete without supporting both.
Here, we will do the reverse of the above task, swapping the Rust and C++ rules.
So, let's assume we have this C++ code:</p>
<pre><code class="language-C++">#include &lt;string&gt;
#include &lt;vector&gt;

namespace cpp_inventory {
struct Item {
  std::string name;
  uint32_t size;
};

struct Inventory {
  std::vector&lt;Item&gt; items;
  uint32_t remaining_space;

  Inventory(uint32_t space) : items(), remaining_space(space) {}

  void add_item(Item item) {
    remaining_space -= item.size;
    items.push_back(std::move(item));
  }

  void add_banana(uint32_t count) {
    add_item(Item{
        .name = "banana",
        .size = 7,
    });
  }
};

} // namespace cpp_inventory
</code></pre>
<p>Create a new cargo project, this time a binary one since we want to write the main function to live inside Rust.
Copy the above code into the <code>inventory.h</code> file.
Then create a <code>main.zng</code> file with the following content:</p>
<pre><code>#cpp_additional_includes "
    #include &lt;inventory.h&gt;
"

type crate::Inventory {
    #layout(size = 16, align = 8);

    constructor(ZngurCppOpaqueOwnedObject);

    #cpp_value "0" "::cpp_inventory::Inventory";
}

type crate::Item {
    #layout(size = 16, align = 8);

    constructor(ZngurCppOpaqueOwnedObject);

    #cpp_value "0" "::cpp_inventory::Item";
}
</code></pre>
<p>And add these to the <code>main.rs</code> file:</p>
<pre><code class="language-Rust">mod generated {
    include!(concat!(env!("OUT_DIR"), "/generated.rs"));
}

struct Inventory(generated::ZngurCppOpaqueOwnedObject);
struct Item(generated::ZngurCppOpaqueOwnedObject);
</code></pre>
<p>This time we will use the Zngur generator inside of cargo build script.
We could still use the <code>zngur-cli</code> but in projects where cargo is the boss, using build script is better.
Add <code>zngur</code> and <code>cc</code> to your build dependencies:</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0"
build-rs = "0.1.2" # This one is optional
zngur = "0.5.0" # Or whatever the latest version is
</code></pre>
<p>Then fill the <code>build.rs</code> file:</p>
<pre><code class="language-Rust">use zngur::Zngur;

fn main() {
    build::rerun_if_changed("main.zng");
    build::rerun_if_changed("impls.cpp");

    let crate_dir = build::cargo_manifest_dir();
    let out_dir = build::out_dir();

    Zngur::from_zng_file(crate_dir.join("main.zng"))
        .with_cpp_file(out_dir.join("generated.cpp"))
        .with_h_file(out_dir.join("generated.h"))
        .with_rs_file(out_dir.join("generated.rs"))
        .generate();

    let my_build = &amp;mut cc::Build::new();
    let my_build = my_build
        .cpp(true)
        .compiler("g++")
        .include(&amp;crate_dir)
        .include(&amp;out_dir);
    let my_build = || my_build.clone();

    my_build()
        .file(out_dir.join("generated.cpp"))
        .compile("zngur_generated");
    my_build().file("impls.cpp").compile("impls");
}
</code></pre>
<p>Now we have a <code>crate::Inventory</code> and a <code>crate::Item</code> that can contain their C++ counterparts.
But there is no way to use them in Rust.
In Zngur, the Rust side can't access C++ opaque objects.
So to make these types useful in Rust, we can add <code>impl</code> blocks for these types in C++.
Add this to the <code>main.zng</code>:</p>
<pre><code>type str {
    wellknown_traits(?Sized);

    fn as_ptr(&amp;self) -&gt; *const u8;
    fn len(&amp;self) -&gt; usize;
}

extern "C++" {
    impl crate::Inventory {
        fn new_empty(u32) -&gt; crate::Inventory;
        fn add_banana(&amp;mut self, u32);
        fn add_item(&amp;mut self, crate::Item);
    }

    impl crate::Item {
        fn new(&amp;str, u32) -&gt; crate::Item;
    }
}
</code></pre>
<p>Now we can define these methods in the C++ and use them in Rust.
Create a file named <code>impls.cpp</code> with this content:</p>
<pre><code class="language-C++">#include "generated.h"
#include &lt;string&gt;

using namespace rust::crate;

Inventory rust::Impl&lt;Inventory&gt;::new_empty(uint32_t space) {
  return Inventory(
      rust::ZngurCppOpaqueOwnedObject::build&lt;cpp_inventory::Inventory&gt;(space));
}

rust::Unit rust::Impl&lt;Inventory&gt;::add_banana(rust::RefMut&lt;Inventory&gt; self,
                                             uint32_t count) {
  self.cpp().add_banana(count);
  return {};
}

rust::Unit rust::Impl&lt;Inventory&gt;::add_item(rust::RefMut&lt;Inventory&gt; self,
                                           Item item) {
  self.cpp().add_item(item.cpp());
  return {};
}

Item rust::Impl&lt;Item&gt;::new_(rust::Ref&lt;rust::Str&gt; name, uint32_t size) {
  return Item(rust::ZngurCppOpaqueOwnedObject::build&lt;cpp_inventory::Item&gt;(
      cpp_inventory::Item{
          .name = ::std::string(reinterpret_cast&lt;const char *&gt;(name.as_ptr()),
                                name.len()),
          .size = size}));
}
</code></pre>
<p>These functions look like some unnecessary boilerplate, but writing them has some benefits:</p>
<ul>
<li>We can convert C++ types to the Rust equivalents in these functions.
For example, converting a pointer and length to a slice,
or <code>&amp;str</code> to <code>std::string</code> that happened in the <code>Item::new</code> above.</li>
<li>We can convert exceptions to Rust <code>Result</code> or <code>Option</code>.</li>
<li>We can control the signature of methods, and use proper lifetimes and mutability for references.
In case of mutability, Rust mutability means exclusiveness,
which might be too restrictive and we may want to consider the C++ type interior mutable.
We can also add nullability with <code>Option</code> or make the function <code>unsafe</code>.</li>
<li>We can choose Rusty names for the functions (like <code>new</code> and <code>len</code>)
or put the functionality in the proper trait
(for example implementing the <code>Iterator</code> trait instead of exposing the <code>.begin</code> and <code>.end</code> functions)</li>
</ul>
<p>Even in the tools that support calling C++ functions directly,
people often end up writing Rust wrappers around C++ types for these reasons.
In Zngur, that code is the wrapper, which lives in the C++ so it can do whatever C++ does.</p>
<p>In the Rust to C++ side, we used <code>zngur_dbg</code> macro to see the result.
We will do the same here with the <code>dbg!</code> macro.
To do that, we need to implement the <code>Debug</code> trait for <code>crate::Inventory</code>.
Add this to the <code>main.zng</code>:</p>
<pre><code>// ...
type ::std::ffi::CStr {
    wellknown_traits(?Sized);

    fn from_ptr(*const i8) -&gt; &amp;::std::ffi::CStr;
    fn to_str(&amp;self) -&gt; ::std::result::Result&lt;&amp;str, ::std::str::Utf8Error&gt;;
}

type ::std::result::Result&lt;&amp;str, ::std::str::Utf8Error&gt; {
    #layout(size = 24, align = 8);

    fn expect(self, &amp;str) -&gt; &amp;str;
}

type ::std::fmt::Result {
    #layout(size = 1, align = 1);

    constructor Ok(());
}

type ::std::fmt::Formatter {
    #only_by_ref;

    fn write_str(&amp;mut self, &amp;str) -&gt; ::std::fmt::Result;
}

extern "C++" {
    // ...

    impl std::fmt::Debug for crate::Inventory {
        fn fmt(&amp;self, &amp;mut ::std::fmt::Formatter) -&gt; ::std::fmt::Result;
    }
}
</code></pre>
<p>and this code to the <code>impls.cpp</code>:</p>
<pre><code class="language-C++">rust::Ref&lt;rust::Str&gt; rust_str_from_c_str(const char* input) {
  return rust::std::ffi::CStr::from_ptr(reinterpret_cast&lt;const int8_t*&gt;(input)).to_str().expect("invalid_utf8"_rs);
}

rust::std::fmt::Result rust::Impl&lt;Inventory, rust::std::fmt::Debug&gt;::fmt(
    rust::Ref&lt;::rust::crate::Inventory&gt; self,
    rust::RefMut&lt;::rust::std::fmt::Formatter&gt; f) {
  ::std::string result = "Inventory { remaining_space: ";
  result += ::std::to_string(self.cpp().remaining_space);
  result += ", items: [";
  bool is_first = true;
  for (const auto &amp;item : self.cpp().items) {
    if (!is_first) {
      result += ", ";
    } else {
      is_first = false;
    }
    result += "Item { name: \"";
    result += item.name;
    result += "\", size: ";
    result += ::std::to_string(item.size);
    result += " }";
  }
  result += "] }";
  return f.write_str(rust_str_from_c_str(result.c_str()));
}
</code></pre>
<p>So now we can write the main function:</p>
<pre><code class="language-Rust">fn main() {
    let mut inventory = Inventory::new_empty(1000);
    inventory.add_banana(3);
    inventory.add_item(Item::new("apple", 5));
    dbg!(inventory);
}
</code></pre>
<p>and run it:</p>
<pre><code>[examples/tutorial_cpp/src/main.rs:12] inventory = Inventory { remaining_space: 974, items: [Item { name: "banana", size: 7 }, Item { name: "banana", size: 7 }, Item { name: "banana", size: 7 }, Item { name: "apple", size: 5 }] }
</code></pre>
<p>You can see the full code at <a href="https://github.com/HKalbasi/zngur/blob/main/examples/tutorial_cpp"><code>examples/tutorial_cpp</code></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="zngur.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="call_rust_from_cpp/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="zngur.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="call_rust_from_cpp/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>






        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
