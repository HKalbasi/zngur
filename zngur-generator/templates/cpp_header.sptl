#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <csignal>
#include <array>
#include <iostream>
#include <functional>
#include <math.h>

<%- self.additional_includes %>

<% for def in self.rust_cfg_defines { %>
#define <%- def %>
<% } %>

<% if let Some(symbols) = &self.panic_to_exception { %>
  namespace rust {
      class Panic {};
  }
  extern "C" {
      uint8_t <%- symbols.detect_panic %>();
      void <%- symbols.take_panic %>();
  }
<% } %>

#define zngur_dbg(x) (::rust::zngur_dbg_impl(__FILE__, __LINE__, #x, x))

namespace rust {

  template<typename T>
  struct __zngur_internal {
    static inline uint8_t* data_ptr(const T& t) noexcept;
    static void assume_init(T& t) noexcept ;
    static void assume_deinit(T& t) noexcept ;
    static inline void check_init(const T&) noexcept;
    static inline size_t size_of() noexcept ;
  };

  template<typename T>
  inline uint8_t* __zngur_internal_data_ptr(const T& t) noexcept {
    return __zngur_internal<T>::data_ptr(t);
  }

  template<typename T>
  void __zngur_internal_assume_init(T& t) noexcept {
    __zngur_internal<T>::assume_init(t);
  }

  template<typename T>
  void __zngur_internal_assume_deinit(T& t) noexcept {
    __zngur_internal<T>::assume_deinit(t);
  }

  template<typename T>
  inline size_t __zngur_internal_size_of() noexcept {
    return __zngur_internal<T>::size_of();
  }

  template<typename T>
  inline void __zngur_internal_move_to_rust(uint8_t* dst, T& t) noexcept {
    memcpy(dst, ::rust::__zngur_internal_data_ptr(t), ::rust::__zngur_internal_size_of<T>());
    ::rust::__zngur_internal_assume_deinit(t);
  }

  template<typename T>
  inline T __zngur_internal_move_from_rust(uint8_t* src) noexcept {
    T t;
    ::rust::__zngur_internal_assume_init(t);
    memcpy(::rust::__zngur_internal_data_ptr(t), src, ::rust::__zngur_internal_size_of<T>());
    return t;
  }

  template<typename T>
  inline void __zngur_internal_check_init(const T& t) noexcept {
    __zngur_internal<T>::check_init(t);
  }

  class ZngurCppOpaqueOwnedObject {
    uint8_t* data;
    void (*destructor)(uint8_t*);

  public:
    template<typename T, typename... Args>
    inline static ZngurCppOpaqueOwnedObject build(Args&&... args) {
        ZngurCppOpaqueOwnedObject o;
        o.data = reinterpret_cast<uint8_t*>(new T(::std::forward<Args>(args)...));
        o.destructor = [](uint8_t* d) {
            delete reinterpret_cast<T*>(d);
        };
        return o;
    }

    template<typename T>
    inline T& as_cpp() { return *reinterpret_cast<T *>(data); }
  };

  template<typename T>
  struct Ref;

  template<typename T>
  struct RefMut;

  template<typename T, size_t OFFSET>
  struct FieldOwned {
    inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
  };

  template<typename T, size_t OFFSET>
  struct FieldRef {
    inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
  };

  template<typename T, size_t OFFSET>
  struct FieldRefMut {
    inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
  };

  template<typename T>
  struct zngur_is_unsized : std::false_type {};
  struct zngur_fat_pointer {
    uint8_t* data;
    size_t metadata;
  };
  template<typename T>
  struct Raw {
      using DataType = typename std::conditional<
          zngur_is_unsized<T>::value,
          zngur_fat_pointer,
          uint8_t*
      >::type;
      DataType data;
      Raw() {}
      Raw(Ref<T> value) {
          memcpy(&data, __zngur_internal_data_ptr<Ref<T>>(value), __zngur_internal_size_of<Ref<T>>());
      }
      Raw(RefMut<T> value) {
          memcpy(&data, __zngur_internal_data_ptr<RefMut<T>>(value), __zngur_internal_size_of<RefMut<T>>());
      }
      Raw(DataType data) : data(data) {
      }
      Raw<T> offset(ssize_t n) {
          return Raw(data + n * __zngur_internal_size_of<T>());
      }
      Ref<T> read_ref() {
          Ref<T> value;
          memcpy(__zngur_internal_data_ptr<Ref<T>>(value), &data, __zngur_internal_size_of<Ref<T>>());
          __zngur_internal_assume_init<Ref<T>>(value);
          return value;
      }
  };
  template<typename T>
  struct RawMut {
      using DataType = typename std::conditional<
          zngur_is_unsized<T>::value,
          zngur_fat_pointer,
          uint8_t*
      >::type;
      DataType data;
      RawMut() {}
      RawMut(RefMut<T> value) {
          memcpy(&data, __zngur_internal_data_ptr<RefMut<T>>(value), __zngur_internal_size_of<RefMut<T>>());
      }
      RawMut(DataType data) : data(data) {
      }
      RawMut<T> offset(ssize_t n) {
          return RawMut(data + n * __zngur_internal_size_of<T>());
      }
      T read() {
          T value;
          memcpy(__zngur_internal_data_ptr<T>(value), data, __zngur_internal_size_of<T>());
          __zngur_internal_assume_init<T>(value);
          return value;
      }
      Ref<T> read_ref() {
          Ref<T> value;
          memcpy(__zngur_internal_data_ptr<Ref<T>>(value), &data, __zngur_internal_size_of<Ref<T>>());
          __zngur_internal_assume_init<Ref<T>>(value);
          return value;
      }
      RefMut<T> read_mut() {
          RefMut<T> value;
          memcpy(__zngur_internal_data_ptr<RefMut<T>>(value), &data, __zngur_internal_size_of<RefMut<T>>());
          __zngur_internal_assume_init<RefMut<T>>(value);
          return value;
      }
      void write(T value) {
          memcpy(data, __zngur_internal_data_ptr<T>(value), __zngur_internal_size_of<T>());
          __zngur_internal_assume_deinit<T>(value);
      }
  };
  template<typename... T>
  struct Tuple;

  using Unit = Tuple<>;

  template<typename T>
  struct ZngurPrettyPrinter;

  class Inherent;

  template<typename Type, typename Trait = Inherent>
  class Impl;

  template<typename T>
  T&& zngur_dbg_impl(const char* file_name, int line_number, const char* exp, T&& input) {
    ::std::cerr << "[" << file_name << ":" << line_number << "] " << exp << " = ";
    ZngurPrettyPrinter<typename ::std::remove_reference<T>::type>::print(input);
    return ::std::forward<T>(input);
  }

  // specializations for Refs of Refs
<% for ref_kind in ["Ref",  "RefMut"] { %>
  <% for nested_ref_kind in ["Ref", "RefMut"] { %>

  template<typename T>
  struct <%- ref_kind %> < <%- nested_ref_kind %> < T > > {
    <%- ref_kind %>() {
      data = 0;
    }
    <%- ref_kind %>(const <%- nested_ref_kind %> < T >& t) {
      data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
    }

    template<size_t OFFSET>
    <%- ref_kind %>(const FieldOwned< <%- nested_ref_kind %> < T >, OFFSET >& f) {
      data = reinterpret_cast<size_t>(&f) + OFFSET;
    }

    <% if ref_kind == "Ref" { %>
    template<size_t OFFSET>
    <%- ref_kind %>(const FieldRef< <%- nested_ref_kind %> < T >, OFFSET >& f) {
      data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
    }
    <% } %>

    template<size_t OFFSET>
    <%- ref_kind %>(const FieldRefMut< <%- nested_ref_kind %> < T >, OFFSET >& f) {
      data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
    }

    <%- nested_ref_kind %>< T >& operator*() {
      return *reinterpret_cast< <%- nested_ref_kind %> < T >*>(data);
    }

  private:
    size_t data;
    friend ::rust::__zngur_internal< <%- ref_kind %> < <%- nested_ref_kind %> < T > > >;
    friend ::rust::ZngurPrettyPrinter< <%- ref_kind %> < <%- nested_ref_kind %> < T > > >;

  };

  template<typename T>
  struct __zngur_internal< <%- ref_kind %> < <%- nested_ref_kind %> < T > > > {
    static inline uint8_t* data_ptr(const <%- ref_kind %> < <%- nested_ref_kind %> < T > >& t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t.data));
    }
    static inline void assume_init(<%- ref_kind %> < <%- nested_ref_kind %> < T > >&) noexcept {}

    static inline void check_init(const <%- ref_kind %> < <%- nested_ref_kind %> < T > >&) noexcept {}

    static inline void assume_deinit(<%- ref_kind %> < <%- nested_ref_kind %> < T > >&) noexcept {}

    static inline size_t size_of() noexcept {
        return __zngur_internal_size_of< <%- nested_ref_kind %> < T > >({});
    }
  };

  template<typename T>
  struct ZngurPrettyPrinter< <%- ref_kind %> < <%- nested_ref_kind %> < T > > > {
    static inline void print(<%- ref_kind %> < <%- nested_ref_kind %> < T > > const& t) {
      ::rust::__zngur_internal_check_init(t);
      ::rust::ZngurPrettyPrinter< <%- nested_ref_kind %> < T > >::print( reinterpret_cast< const <%- nested_ref_kind %> < T > &>(t.data) );
    }
  };

  <% } %>
<% } %>

<% for ty in self.builtin_types() { %>
  <% let needs_endif = ty == "::size_t"; %>
  <% if needs_endif { %>
    #if defined(__APPLE__) || defined(__wasm__)
  <% } %>

  template<>
  struct __zngur_internal< <%- ty %> > {
    static inline uint8_t* data_ptr(const <%- ty %>& t) noexcept {
      return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }
    static inline void assume_init(<%- ty %>&) noexcept {}
    static inline void assume_deinit(<%- ty %>&) noexcept {}
    static inline void check_init(<%- ty %>&) noexcept {}
    static inline size_t size_of() noexcept {
      return sizeof(<%- ty %>);
    }
  };

  template<>
  struct __zngur_internal< <%- ty %>* > {
    static inline uint8_t* data_ptr(<%- ty %>* const & t) noexcept {
      return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }
    static inline void assume_init(<%- ty %>*&) noexcept {}
    static inline void assume_deinit(<%- ty %>*&) noexcept {}
    static inline void check_init(<%- ty %>*&) noexcept {}
    static inline size_t size_of() noexcept {
      return sizeof(<%- ty %>);
    }
  };

  template<>
  struct __zngur_internal< <%- ty %> const* > {
    static inline uint8_t* data_ptr(<%- ty %> const* const & t) noexcept {
      return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }
    static inline void assume_init(<%- ty %> const*&) noexcept {}
    static inline void assume_deinit(<%- ty %> const*&) noexcept {}
    static inline void check_init(<%- ty %> const*&) noexcept {}
    static inline size_t size_of() noexcept {
      return sizeof(<%- ty %>);
    }
  };


  template<>
  struct Ref< <%- ty %> > {
    Ref() {
      data = 0;
    }
    Ref(const <%- ty %>& t) {
      data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
    }

    template<size_t OFFSET>
    Ref(const FieldOwned< <%- ty %>, OFFSET >& f) {
      data = reinterpret_cast<size_t>(&f) + OFFSET;
    }

    template<size_t OFFSET>
    Ref(const FieldRef< <%- ty %>, OFFSET >& f) {
      data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
    }

    template<size_t OFFSET>
    Ref(const FieldRefMut< <%- ty %>, OFFSET >& f) {
      data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
    }

    <%- ty %>& operator*() {
      return *reinterpret_cast< <%- ty %>*>(data);
    }

  private:
    size_t data;
    friend ::rust::__zngur_internal<Ref< <%- ty %> > >;
    friend ::rust::ZngurPrettyPrinter< Ref< <%- ty %> > >;

  };

  template<>
  struct RefMut< <%- ty %> > {
    RefMut() {
      data = 0;
    }

    RefMut(<%- ty %>& t) {
      data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
    }

    template<size_t OFFSET>
    RefMut(const FieldOwned< <%- ty %>, OFFSET >& f) {
        data = reinterpret_cast<size_t>(&f) + OFFSET;
    }

    template<size_t OFFSET>
    RefMut(const FieldRefMut< <%- ty %>, OFFSET >& f) {
        data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
    }

    <%- ty %>& operator*() {
        return *reinterpret_cast< <%- ty %>*>(data);
    }
  private:
    size_t data;
    friend ::rust::__zngur_internal<RefMut< <%- ty %> > >;
    friend ::rust::ZngurPrettyPrinter< Ref< <%- ty %> > >;
  };

  <% let printable = ty.starts_with("int") || ty.starts_with("uint") || ty.starts_with("::size_t") || ty.starts_with("::double") || ty.starts_with("::float"); %>
  <% if printable { %>
    template<>
    struct ZngurPrettyPrinter< <%- ty %> > {
      static inline void print(<%- ty %> const& t) {
        ::std::cerr << t << ::std::endl;
      }
    };
  <% } %>

  <% if needs_endif { %>
    #endif
  <% } %>

// end builtin types
<% } %>

} // namespace rust

extern "C" {
  <% for f in self.fn_deps { %>
    void <%- f.sig.rust_link_name %> (
      <% for n in 0..f.sig.inputs.len() { %>
        uint8_t* i<%- n %>,
      <% } %>
      uint8_t* o
    ) noexcept ;
  <% } %>

  <% for td in self.type_defs { %>
    <% for method in &td.methods { %>
      void <%- method.sig.rust_link_name %> (
        <% for n in 0..method.sig.inputs.len() { %>
          uint8_t* i<%- n %>,
        <% } %>
        uint8_t* o
      ) noexcept ;
    <% } %>

    <% for constructor in &td.constructors { %>
      void <%- constructor.rust_link_name %> (
        <% for n in 0..constructor.inputs.len() { %>
          uint8_t* i<%- n %>,
        <% } %>
        uint8_t* o
      ) noexcept ;
    <% } %>

    <% if let Some(cpp_value) = &td.cpp_value { %>
      ::rust::ZngurCppOpaqueOwnedObject* <%- cpp_value.0 %>(uint8_t*);
    <% } %>

    <% if let CppLayoutPolicy::HeapAllocated { size_fn, alloc_fn, free_fn } = &td.layout { %>
      size_t <%- size_fn %>();
      uint8_t* <%- alloc_fn %>();
      void <%- free_fn %>(uint8_t*);
    <% } %>

    <% for tr in &td.wellknown_traits { %>
      <% /* TODO: switch to match. */ %>
      <% if let ZngurWellknownTraitData::Debug { pretty_print, debug_print } = tr { %>
        void <%- pretty_print %>(uint8_t*);
        void <%- debug_print %>(uint8_t*);
      <% } else if let ZngurWellknownTraitData::Drop { drop_in_place } = tr { %>
        void <%- drop_in_place %>(uint8_t*);
      <% } else if let ZngurWellknownTraitData::Unsized | ZngurWellknownTraitData::Copy = tr { %>
        <% /* No output for Unsized and Copy traits */ %>
      <% } %>
    <% } %>

    <% for (_, td) in self.trait_defs { %>
      <% if let CppTraitDefinition::Fn { sig } = td { %>
        void <%- sig.rust_link_name %>(uint8_t* data, void destructor(uint8_t *),
                                       void call(uint8_t *,
                                          <% for n in 0..sig.inputs.len() { %> uint8_t *i<%- n %>, <% } %>uint8_t *o),
                                       uint8_t *o
        );
      <% } else if let CppTraitDefinition::Normal { link_name, link_name_ref, .. } = td { %>
        void <%- link_name %>(uint8_t *data, void destructor(uint8_t *), uint8_t *o);
        void <%- link_name_ref %>(uint8_t *data, uint8_t *o);
      <% } %>
    <% } %>

  // end self.type_defs
  <% } %>

} // extern "C"

<% for td in self.type_defs { %>
  <%- td.ty.header() %>
<% } %>

<% for imp in self.exported_impls { %>
  <%- imp.ty.header() %>
  <% if let Some(tr) = &imp.tr { %>
    <%- tr.header() %>
  <% } %>
<% } %>

namespace rust {

<% for td in self.type_defs {
    if td.wellknown_traits.contains(&ZngurWellknownTraitData::Unsized) { %>
        template<>
        struct zngur_is_unsized< <%- td.ty %> > : ::std::true_type {};
<%  } 
} %>

}

<% for (_, td) in self.trait_defs { %>
  <% if let CppTraitDefinition::Normal { as_ty, methods, .. } = td { %>
    <%- as_ty.path.open_namespace() %>
    <%- as_ty.specialization_decl() %> {
      public:
        virtual ~<%- as_ty.path.name() %>() {};
        <% for method in methods { %>
          virtual <%- method.output %> <%- method.name %> (
            <%- splat!(&method.inputs, |n, x|, "{x} i{n}") %>
          ) = 0;
        <% } %>
      };
    <%- as_ty.path.close_namespace() %>
  <% } %>
<% } %>

<% for td in self.type_defs { %>
  <% let is_copy = td.wellknown_traits.contains(&ZngurWellknownTraitData::Copy); %>
  <% let is_unsized = td.wellknown_traits.contains(&ZngurWellknownTraitData::Unsized); %>
  <% let name = td.ty.path.name(); %>

  namespace rust {
    template<>
    struct __zngur_internal< <%- td.ty %> > {
      static inline uint8_t* data_ptr(const <%- td.ty %>& t) noexcept ;
      static inline void check_init(const <%- td.ty %>& t) noexcept ;
      static inline void assume_init(<%- td.ty %>& t) noexcept ;
      static inline void assume_deinit(<%- td.ty %>& t) noexcept ;
      static inline size_t size_of() noexcept ;
    };
  }

  <%- td.ty.path.open_namespace() %>
    <%- td.ty.specialization_decl() %> {
    <% match td.layout { CppLayoutPolicy::OnlyByRef => { %>
      public:
        <%- name %>() = delete;
    <% } CppLayoutPolicy::StackAllocated { size, align } => { %>
      private:
        alignas(<%- align %>) mutable ::std::array< ::uint8_t, <%- size %>> data;
    <% } CppLayoutPolicy::HeapAllocated { .. } => { %>
      private:
        ::uint8_t* data;
    <% }
    } %>

    <% match td.layout { CppLayoutPolicy::OnlyByRef => { %>
    <% } CppLayoutPolicy::HeapAllocated { .. } | CppLayoutPolicy::StackAllocated { .. } => { %>
      friend ::rust::__zngur_internal< <%- td.ty %> >;
      friend ::rust::ZngurPrettyPrinter< <%- td.ty %> >;

    <% if td.ty.path.to_string() == "::rust::Bool" { %>
      public:
        operator bool() {
          return data[0];
        }
        Bool(bool b) {
          data[0] = b;
        }
    <% } %>

    <% if td.ty.path.to_string() == "::rust::Char" { %>
      public:
        operator char32_t() const {
          return *reinterpret_cast<const char32_t*>(data.data());
        }
        Char(char32_t c) {
          *reinterpret_cast<char32_t*>(data.data()) = c;
        }
    <% } %>

    <% if !is_copy { %>
      bool drop_flag;
    <% } %>

    <% let (alloc_heap, free_heap, copy_data) = match &td.layout {
      CppLayoutPolicy::StackAllocated { .. } => (
        "".to_owned(),
        "".to_owned(),
        "this->data = other.data;".to_owned(),
      ),
      CppLayoutPolicy::HeapAllocated { size_fn, alloc_fn, free_fn } => (
        format!("data = {}();", alloc_fn),
        format!("{}(data);", free_fn),
        format!("memcpy(this->data, other.data, {}());", size_fn),
      ),
      CppLayoutPolicy::OnlyByRef => unreachable!(),
    }; %>

    public:
      <% if is_copy { %>
        <%- name %>() { <%- alloc_heap %> }
        ~<%- name %>() { <%- free_heap %> }
        <%- name %>(const <%- name %>& other) {
          <%- alloc_heap %>
          <%- copy_data %>
        }
        <%- name %>& operator=(const <%- name %>& other) {
          <%- copy_data %>
          return *this;
        }
        <%- name %>(<%- name %>&& other) {
          <%- alloc_heap %>
          <%- copy_data %>
        }
        <%- name %>& operator=(<%- name %>&& other) {
          <%- copy_data %>
          return *this;
        }
      <% } else { /* !is_copy */ %>
        <% let drop_in_place = td.wellknown_traits.iter().find_map(|x| match x {
          ZngurWellknownTraitData::Drop { drop_in_place } => Some(drop_in_place),
          _ => None,
        }).unwrap(); %>

        <%- name %>() : drop_flag(false) { <%- alloc_heap %> }
        ~<%- name %>() {
          if (drop_flag) {
            <%- drop_in_place %>(::rust::__zngur_internal_data_ptr(*this));
          }
          <%- free_heap %>
        }
        <%- name %>(const <%- name %>& other) = delete;
        <%- name %>& operator=(const <%- name %>& other) = delete;
        <%- name %>(<%- name %>&& other) : drop_flag(false) {
          <%- alloc_heap %>
          *this = ::std::move(other);
        }
        <%- name %>& operator=(<%- name %>&& other) {
          if (this != &other) {
            if (drop_flag) {
              <%- drop_in_place %>(::rust::__zngur_internal_data_ptr(*this));
            }
            this->drop_flag = other.drop_flag;
            <%- copy_data %>
            other.drop_flag = false;
          }
          return *this;
        }
      <% } %>

      <% match &td.from_trait { Some(RustTrait::Fn { inputs, output, .. }) => { %>
        static inline <%- name %> make_box(
          ::std::function< <%- output.into_cpp() %> (<%- inputs.iter().map(|x| x.into_cpp()).join(", ") %>) > f
        );
      <% } Some(RustTrait::Normal{..}) => { %>
        template<typename T, typename... Args>
        static inline <%- name %> make_box(Args&&... args);
      <% } None => { %>
      <% }
      } %>

      <% if let Some(cpp_value) = &td.cpp_value { %>
          inline <%- cpp_value.1 %>& cpp() {
              return (*<%- cpp_value.0 %>(::rust::__zngur_internal_data_ptr(*this))).as_cpp< <%- cpp_value.1 %> >();
          }
      <% } %>

    <% }
    } %>

    <% for method in &td.methods { %>
        static <%- method.sig.output %> <%- method.name %>(
          <%- splat!(&method.sig.inputs, |n, ty|, "{ty} i{n}") %>
        ) noexcept ;
        <% if method.kind != ZngurMethodReceiver::Static { %>
            <%- method.sig.output %> <%- method.name %>(
              <%- splat!(method.sig.inputs.iter().skip(1), |n, ty|, "{ty} i{n}") %>
            )
            <% if method.kind == ZngurMethodReceiver::Ref(Mutability::Not) { %> const <% } %> noexcept ;
        <% } %>
    <% } %>

    <% for constructor in &td.constructors { %>
      <%- td.ty.path.0.last().unwrap() %>(
        <%- splat!(&constructor.inputs, |n, ty|, "{ty} i{n}") %>
      ) noexcept ;
    <% } %>

    <% for field in &td.fields { %>
      [[no_unique_address]] ::rust::FieldOwned<
        <%- field.ty.into_cpp() %>,
        <%- field.offset %>
      > <%- cpp_handle_field_name(&field.name) %>;
    <% } %>

  }; // <%- td.ty.specialization_decl() %>

<%- td.ty.path.close_namespace() %>

namespace rust {

<% match &td.layout { CppLayoutPolicy::StackAllocated { size, align: _ } => { %>
  inline size_t __zngur_internal< <%- td.ty %> >::size_of() noexcept {
      return <%- size %>;
  }
<% } CppLayoutPolicy::HeapAllocated { size_fn, .. } => { %>
  inline size_t __zngur_internal< <%- td.ty %> >::size_of() noexcept {
      return <%- size_fn %>();
  }
<% } CppLayoutPolicy::OnlyByRef => { %>
  <% /* OnlyByRef types don't need these template specializations */ %>
<% }
} %>

<% if td.layout != CppLayoutPolicy::OnlyByRef { %>
  <% if is_copy { %>
    inline void __zngur_internal< <%- td.ty %> >::check_init(const <%- td.ty %>&) noexcept {}
    inline void __zngur_internal< <%- td.ty %> >::assume_init(<%- td.ty %>&) noexcept {}
    inline void __zngur_internal< <%- td.ty %> >::assume_deinit(<%- td.ty %>&) noexcept {}
  <% } else { %>
    inline void __zngur_internal< <%- td.ty %> >::check_init(const <%- td.ty %>& t) noexcept {
        if (!t.drop_flag) {
            ::std::cerr << "Use of uninitialized or moved Zngur Rust object with type <%- td.ty %>" << ::std::endl;
            while (true) raise(SIGSEGV);
        }
    }

    inline void __zngur_internal< <%- td.ty %> >::assume_init(<%- td.ty %>& t) noexcept {
        t.drop_flag = true;
    }

    inline void __zngur_internal< <%- td.ty %> >::assume_deinit(<%- td.ty %>& t) noexcept {
        ::rust::__zngur_internal_check_init< <%- td.ty %> >(t);
        t.drop_flag = false;
    }
  <% } %>

  inline uint8_t* __zngur_internal< <%- td.ty %> >::data_ptr(<%- td.ty %> const & t) noexcept {
    <% if let CppLayoutPolicy::HeapAllocated {..} = td.layout { %>
      return const_cast<uint8_t*>(t.data);
    <% } else { %>
      return const_cast<uint8_t*>(t.data.data());
    <% } %>
  }


<% } %>

} // namespace rust

namespace rust {

  template<>
  struct RefMut< <%- td.ty %> > {
  private:
    <% if is_unsized { %> ::std::array<size_t, 2> <% } else { %> size_t <% } %> data;
    friend ::rust::__zngur_internal< ::rust::RefMut< <%- td.ty %> > >;
    friend ::rust::ZngurPrettyPrinter< ::rust::RefMut< <%- td.ty %> > >;
  public:
    RefMut() {
      data = <% if is_unsized { %> {0, 0} <% } else { %> 0 <% } %>;
    }

    friend Ref< <%- td.ty %> >;

    <% if !is_unsized && !matches!(td.layout, CppLayoutPolicy::OnlyByRef) { %>
      <% for field in &td.fields { %>
        [[no_unique_address]] ::rust::FieldRefMut<
            <%- field.ty.into_cpp() %>,
            <%- field.offset %>
        > <%- cpp_handle_field_name(&field.name) %>;
      <% } %>
    <% } %>

    <% if !is_unsized && !matches!(td.layout, CppLayoutPolicy::OnlyByRef) { %>
      RefMut(const <%- td.ty %>& t) {
        ::rust::__zngur_internal_check_init< <%- td.ty %> >(t);
        data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
      }
    <% } %>

    <% if !is_unsized { %>
      template<size_t OFFSET>
      RefMut(const FieldOwned< <%- td.ty %>, OFFSET >& f) {
          data = reinterpret_cast<size_t>(&f) + OFFSET;
      }
      template<size_t OFFSET>
      RefMut(const FieldRefMut< <%- td.ty %>, OFFSET >& f) {
          data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
      }
    <% } %>

    <% match &td.from_trait_ref { Some(RustTrait::Fn { inputs, output, .. }) => { %>
      <% let as_std_function = format!("::std::function< {}({})>", output.into_cpp(), inputs.iter().map(|x| x.into_cpp()).join(", ")); %>
      inline <%- td.ty.path.name() %>(<%- as_std_function %> f);
      <% } Some(tr @ RustTrait::Normal { .. }) => { %>
        <% let tr = tr.into_cpp(); %>
        inline RefMut(<%- tr %>& arg);
      <% } None => { %>
      <% }
    } %>

    <% if let Some(cpp_value) = &td.cpp_value { %>
      inline <%- cpp_value.1 %>& cpp() {
          return (*<%- cpp_value.0 %>(reinterpret_cast<uint8_t*>(data))).as_cpp< <%- cpp_value.1 %> >();
      }
    <% } %>

    <% if let Some(cpp_ref) = &td.cpp_ref { %>
      inline <%- cpp_ref.0 %>& cpp() {
          return *reinterpret_cast< <%- cpp_ref.0 %>* >(data);
      }
      inline RefMut(const <%- cpp_ref.0 %>& t) : data(reinterpret_cast<size_t>(&t)) {}
    <% } %>

    <% for method in &td.methods { %>
      <% if let ZngurMethodReceiver::Ref(_) = method.kind { %>
        <%- method.sig.output %> <%- method.name %>(
          <%- splat!(method.sig.inputs.iter().skip(1), |n, ty|, "{ty} i{n}") %>
        ) const noexcept ;
      <% } %>
    <% } %>

  }; // struct RefMut< <%- td.ty %> >

  template<>
  struct __zngur_internal< RefMut < <%- td.ty %> > > {
    static inline uint8_t* data_ptr(const RefMut< <%- td.ty %> >& t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t.data));
    }
    static inline void assume_init(RefMut< <%- td.ty %> >&) noexcept {}
    static inline void check_init(const RefMut< <%- td.ty %> >&) noexcept {}
    static inline void assume_deinit(RefMut< <%- td.ty %> >&) noexcept {}
    static inline size_t size_of() noexcept {
        return <% if is_unsized { %>16<% } else { %>8<% } %>;
    }
  };

} // namespace rust

// Ref specialization
<% if td.ty.path.to_string() == "::rust::Str" { %>
    auto operator""_rs(const char* input, size_t len) -> ::rust::Ref<::rust::Str>;
<% } %>

namespace rust {

  template<>
  struct Ref< <%- td.ty %> > {
  private:
    <% if is_unsized { %> ::std::array<size_t, 2> <% } else { %> size_t <% } %> data;
    friend ::rust::__zngur_internal< ::rust::Ref< <%- td.ty %> > >;
    friend ::rust::ZngurPrettyPrinter< ::rust::Ref< <%- td.ty %> > >;
  public:
    Ref() {
      data = <% if is_unsized { %> {0, 0} <% } else { %> 0 <% } %>;
    }

    <% if !is_unsized && !matches!(td.layout, CppLayoutPolicy::OnlyByRef) { %>
      Ref(const <%- td.ty %>& t) {
        ::rust::__zngur_internal_check_init< <%- td.ty %> >(t);
        data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
      }

      <% for field in &td.fields { %>
          [[no_unique_address]] ::rust::FieldRef<
              <%- field.ty.into_cpp() %>,
              <%- field.offset %>
          > <%- cpp_handle_field_name(&field.name) %>;
      <% } %>

    <% } %>

      Ref(RefMut< <%- td.ty %> > rm) {
          data = rm.data;
      }

    <% if !is_unsized { %>
      template<size_t OFFSET>
      Ref(const FieldOwned< <%- td.ty %>, OFFSET >& f) {
          data = reinterpret_cast<size_t>(&f) + OFFSET;
      }

      template<size_t OFFSET>
      Ref(const FieldRef< <%- td.ty %>, OFFSET >& f) {
          data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
      }

      template<size_t OFFSET>
      Ref(const FieldRefMut< <%- td.ty %>, OFFSET >& f) {
          data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
      }
    <% } %>

    <% match &td.from_trait_ref { Some(RustTrait::Fn { inputs, output, .. }) => { %>
      <% let as_std_function = format!("::std::function< {}({})>", output.into_cpp(), inputs.iter().map(|x| x.into_cpp()).join(", ")); %>
      inline <%- td.ty.path.name() %>(<%- as_std_function %> f);
    <% } Some(tr @ RustTrait::Normal { .. }) => { %>
      <% let tr = tr.into_cpp(); %>
      inline Ref(<%- tr %>& arg);
    <% } None => { %>
    <% }
    } %>

    <% if let Some(cpp_value) = &td.cpp_value { %>
      inline <%- cpp_value.1 %>& cpp() {
        return (*<%- cpp_value.0 %>(reinterpret_cast<uint8_t*>(data))).as_cpp< <%- cpp_value.1 %> >();
      }
    <% } %>

    <% if let Some(cpp_ref) = &td.cpp_ref { %>
      inline <%- cpp_ref.0 %>& cpp() {
        return *reinterpret_cast< <%- cpp_ref.0 %>* >(data);
      }
      inline Ref(const <%- cpp_ref.0 %>& t) : data(reinterpret_cast<size_t>(&t)) {}
    <% } %>

    <% for method in &td.methods { %>
      <% if let ZngurMethodReceiver::Ref(m) = method.kind { %>
        <% if m != Mutability::Mut { %>
          <%- method.sig.output %> <%- method.name %>(<%- method.sig.inputs.iter().skip(1).enumerate().map(|(n, ty)| format!("{ty} i{n}")).join(", ") %>) const noexcept ;
        <% } %>
      <% } %>
    <% } %>

    <% if td.ty.path.to_string() == "::rust::Str" { %>
      friend auto ::operator""_rs(const char* input, size_t len) -> ::rust::Ref<::rust::Str>;
    <% } %>
};

<% for ref_kind in ["Ref", "Raw", "RawMut"] { %>

template<>
struct __zngur_internal< <%- ref_kind %> < <%- td.ty %> > > {
  static inline uint8_t* data_ptr(const <%- ref_kind %> < <%- td.ty %> >& t) noexcept {
      return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t.data));
  }
  static inline void assume_init(<%- ref_kind %> < <%- td.ty %> >&) noexcept {}
  static inline void check_init(const <%- ref_kind %> < <%- td.ty %> >&) noexcept {}
  static inline void assume_deinit(<%- ref_kind %> < <%- td.ty %> >&) noexcept {}
  static inline size_t size_of() noexcept {
      return <% if is_unsized { %>16<% } else { %>8<% } %>;
  }
};

<% } %>

} // namespace rust

<% if td.ty.path.to_string() == "::rust::Str" { %>
  inline ::rust::Ref<::rust::Str> operator""_rs(const char* input, size_t len) {
    ::rust::Ref<::rust::Str> o;
    o.data[0] = reinterpret_cast<size_t>(input);
    o.data[1] = len;
    return o;
  }
<% } %>

<% if td.ty.path.to_string() == "::rust::Char" { %>
  inline ::rust::Char operator""_rc(char32_t c) {
    return ::rust::Char(c);
  }
<% } %>

namespace rust {

// Field specializations
<% for field_kind in &["FieldOwned", "FieldRef", "FieldRefMut"] { %>

  template<size_t OFFSET>
  struct <%- field_kind %>< <%- td.ty %>, OFFSET > {

    <% for field in &td.fields { %>
      [[no_unique_address]] <%- field_kind %><
        <%- field.ty.into_cpp() %>,
        OFFSET + <%- field.offset %>
      > <%- cpp_handle_field_name(&field.name) %>;
    <% } %>

    <% for method in &td.methods { %>
      <% if let ZngurMethodReceiver::Ref(m) = method.kind { %>
        <% if !(m == Mutability::Mut && *field_kind == "FieldRef") { %>
          <%- method.sig.output %> <%- method.name %>(
            <%- splat!(method.sig.inputs.iter().skip(1), |n, ty|, "{ty} i{n}") %>
          ) const noexcept ;
        <% } %>
      <% } %>
    <% } %>

  }; // struct <%- field_kind %>< <%- td.ty %>, OFFSET >
<% } /* for field_kind in &[...] */ %>

} // namespace rust

<% } /* for td in self.type_defs */ %>

<% for td in self.type_defs { %>

  <% let cpp_type = td.ty.to_string(); %>
  <% let name = cpp_type.strip_prefix("::").unwrap(); %>

  <% for c in &td.constructors { %>
    <% let fn_name = name.to_owned() + "::" + td.ty.path.0.last().unwrap(); %>
    inline <%- fn_name %>(<%- splat!(&c.inputs, |n, ty|, "{ty} i{n}") %>) noexcept {
      ::rust::__zngur_internal_assume_init(*this);
      <%- c.rust_link_name %>(
        <% for n in 0..c.inputs.len() { %>
          ::rust::__zngur_internal_data_ptr(i<%- n %>),
        <% } %>
        ::rust::__zngur_internal_data_ptr(*this)
      );
      <% for n in 0..c.inputs.len() { %>
        ::rust::__zngur_internal_assume_deinit(i<%- n %>);
      <% } %>
    }
  <% } %>

  <% let tr = &td.from_trait.as_ref().and_then(|k| self.trait_defs.get(k)); %>
  <% match tr { Some(CppTraitDefinition::Fn { sig }) => { %>
    <% let as_std_function = format!("::std::function< {}({})>", sig.output, sig.inputs.iter().join(", ")); %>
    <% let ii_names = splat!(&sig.inputs, |n, x|, "::rust::__zngur_internal_move_from_rust< {x} >(i{n})"); %>
    <% let uint8_t_ix = if sig.inputs.is_empty() { "".to_owned() } else { splat!(&sig.inputs, |n, _ty|, "uint8_t* i{n}") + ", " }; %>
    <% let out_ty = &sig.output; %>

    inline <%- name %> <%- name %>::make_box(<%- as_std_function %> f) {
      auto data = new <%- as_std_function %>(f);
      <%- name %> o;
      ::rust::__zngur_internal_assume_init(o);
      <%- sig.rust_link_name %> (
        reinterpret_cast<uint8_t*>(data),
        [](uint8_t *d) { delete reinterpret_cast< <%- as_std_function %>*>(d); },
        [](uint8_t *d, <%- uint8_t_ix %> uint8_t* o) {
          auto dd = reinterpret_cast< <%- as_std_function %> *>(d);
          <%- out_ty %> oo = (*dd)(<%- ii_names %>);
          ::rust::__zngur_internal_move_to_rust< <%- out_ty %> >(o, oo);
        },
        ::rust::__zngur_internal_data_ptr(o)
      );
      return o;
    }

  <% } Some(CppTraitDefinition::Normal { as_ty, methods: _, link_name, link_name_ref: _ }) => { %>
    template <typename T, typename... Args>
    <%- name %> <%- name %>::make_box(Args&&... args) {
      auto data = new T(::std::forward<Args>(args)...);
      auto data_as_impl = dynamic_cast< <%- as_ty %>*>(data);
      <%- name %> o;
      ::rust::__zngur_internal_assume_init(o);
      <%- link_name %> (
        reinterpret_cast<uint8_t*>(data_as_impl),
        [](uint8_t *d) { delete reinterpret_cast< <%- as_ty %>*>(d); },
        ::rust::__zngur_internal_data_ptr(o)
      );
      return o;
    }

  <% } None => { %>
  <% }
  } %>

  <% let tr = &td.from_trait_ref.as_ref().and_then(|k| self.trait_defs.get(k)); %>
  <% match tr { Some(CppTraitDefinition::Fn { .. }) => { %>
    <# TODO: Implement this #>
  <% } Some(CppTraitDefinition::Normal { as_ty, methods: _, link_name: _, link_name_ref }) => { %>
    <% for ref_kind in ["Ref", "RefMut"] { %>
      rust::<%- ref_kind %>< <%- name %> >::<%- ref_kind %>(<%- as_ty %>& args) {
        auto data_as_impl = &args;
        ::rust::__zngur_internal_assume_init(*this);
        <%- link_name_ref %>(
          (uint8_t *)data_as_impl,
          ::rust::__zngur_internal_data_ptr(*this)
        );
      }
    <% } %>
  <% } None => { %>
  <% }
  } %>

  <% let is_unsized = td.wellknown_traits.contains(&ZngurWellknownTraitData::Unsized); %>
  <% for method in &td.methods { %>
    <% let fn_name = name.to_owned() + "::" + &method.name; %>
    <% let inputs = &method.sig.inputs; %>
    inline <%- method.sig.output %> <%- fn_name %> (
      <%- splat!(inputs, |n, ty|, "{ty} i{n}") %>
    ) noexcept {
      <%- method.sig.output %> o{};
      <% for n in 0..inputs.len() { %> ::rust::__zngur_internal_assume_deinit(i<%- n %>); <% } %>
      <%- method.sig.rust_link_name %> (
        <% if !inputs.is_empty() { %><%- splat!(inputs, |n, _ty|, "::rust::__zngur_internal_data_ptr(i{n})") %>,<% } %>
        ::rust::__zngur_internal_data_ptr(o)
      );
      <%- self.panic_handler() %>
      ::rust::__zngur_internal_assume_init(o);
      return o;
    }

    <% if let ZngurMethodReceiver::Ref(m) = method.kind { %>
      <% let ref_kinds: &[&str] = match m {
        Mutability::Mut => &["RefMut"],
        Mutability::Not => &["Ref", "RefMut"],
      }; %>
      <% let field_kinds: &[&str] = match m {
        Mutability::Mut => &["FieldOwned", "FieldRefMut"],
        Mutability::Not => &["FieldOwned", "FieldRefMut", "FieldRef"],
      }; %>

      <% for field_kind in field_kinds { %>
        <% let CppFnSig { rust_link_name: _, inputs, output } = &method.sig; %>
        template<size_t OFFSET>
        inline <%- output %> rust::<%- field_kind %>< <%- td.ty %>, OFFSET >::<%- method.name %>(
            <%- splat!(inputs.iter().skip(1), |n, ty|, "{ty} i{n}") %>
        ) const noexcept {
          return <%- fn_name %>(
            *this
            <% for n in 0..(inputs.len() - 1) { %> , ::std::move(i<%- n %>) <% } %>
          );
        }
      <% } %>

      <% for ref_kind in ref_kinds { %>
        <% let CppFnSig { rust_link_name: _, inputs, output } = &method.sig; %>
        inline <%- output %> rust::<%- ref_kind %>< <%- td.ty %> >::<%- method.name %>(
            <%- splat!(inputs.iter().skip(1), |n, ty|, "{ty} i{n}") %>
        ) const noexcept {
          return <%- fn_name %>(
            *this
            <% for n in 0..(inputs.len() - 1) { %> , ::std::move(i<%- n %>) <% } %>
          );
        }
      <% } %>

    <% } %>

    <% if !is_unsized && !matches!(td.layout, CppLayoutPolicy::OnlyByRef) && method.kind != ZngurMethodReceiver::Static { %>
      <% let CppFnSig { rust_link_name: _, inputs, output } = &method.sig; %>
      <% let this_arg = match method.kind {
        ZngurMethodReceiver::Ref(_) => "*this",
        ZngurMethodReceiver::Move => "::std::move(*this)",
        ZngurMethodReceiver::Static => unreachable!(),
      }; %>

      inline <%- output %> <%- fn_name %>(
            <%- splat!(inputs.iter().skip(1), |n, ty|, "{ty} i{n}") %>
      ) <% if method.kind == ZngurMethodReceiver::Ref(Mutability::Not) { %> const <% } %> noexcept {
        return <%- fn_name %>(
          <%- this_arg %>
          <% for n in 0..(inputs.len() - 1) { %> , ::std::move(i<%- n %>) <% } %>
        );
      }
    <% }%>
  <% } %>

namespace rust {

  <% for tr in &td.wellknown_traits { %>
    <% if let ZngurWellknownTraitData::Debug { pretty_print, debug_print: _ } = tr { %>
      <% if !is_unsized { %>
        template<>
        struct ZngurPrettyPrinter< <%- td.ty %> > {
          static inline void print( <%- td.ty %> const& t) {
            ::rust::__zngur_internal_check_init< <%- td.ty %> >(t);
            <%- pretty_print %>(::rust::__zngur_internal_data_ptr(t));
          }
        };

        template<>
        struct ZngurPrettyPrinter< Ref< <%- td.ty %> > > {
          static inline void print(Ref< <%- td.ty %> > const& t) {
            ::rust::__zngur_internal_check_init< Ref< <%- td.ty %> > >(t);
            <%- pretty_print %>(reinterpret_cast<uint8_t*>(t.data));
          }
        };

        template<>
        struct ZngurPrettyPrinter< RefMut< <%- td.ty %> > > {
          static inline void print(RefMut< <%- td.ty %> > const& t) {
            ::rust::__zngur_internal_check_init< RefMut< <%- td.ty %> > >(t);
            <%- pretty_print %>(reinterpret_cast<uint8_t*>(t.data));
          }
        };

        template<size_t OFFSET>
        struct ZngurPrettyPrinter< FieldOwned< <%- td.ty %>, OFFSET > > {
          static inline void print(FieldOwned< <%- td.ty %>, OFFSET > const& t) {
            ZngurPrettyPrinter< Ref< <%- td.ty %> > >::print(t);
          }
        };

        template<size_t OFFSET>
        struct ZngurPrettyPrinter< FieldRef< <%- td.ty %>, OFFSET > > {
          static inline void print(FieldRef< <%- td.ty %>, OFFSET > const& t) {
            ZngurPrettyPrinter< Ref< <%- td.ty %> > >::print(t);
          }
        };

        template<size_t OFFSET>
        struct ZngurPrettyPrinter< FieldRefMut< <%- td.ty %>, OFFSET > > {
          static inline void print(FieldRefMut< <%- td.ty %>, OFFSET > const& t) {
            ZngurPrettyPrinter< Ref< <%- td.ty %> > >::print(t);
          }
        };
      <% } else { %>
        template<>
        struct ZngurPrettyPrinter< Ref< <%- td.ty %> > > {
          static inline void print(Ref< <%- td.ty %> > const& t) {
            ::rust::__zngur_internal_check_init< Ref< <%- td.ty %> > >(t);
            <%- pretty_print %>(::rust::__zngur_internal_data_ptr< Ref< <%- td.ty %> > >(t));
          }
        };

        template<>
        struct ZngurPrettyPrinter< RefMut< <%- td.ty %> > > {
          static inline void print(RefMut< <%- td.ty %> > const& t) {
            ::rust::__zngur_internal_check_init< RefMut< <%- td.ty %> > >(t);
            <%- pretty_print %>(::rust::__zngur_internal_data_ptr< RefMut< <%- td.ty %> > >(t));
          }
        };
      <% } %>
    <% } %>
  <% } %>
} // namespace rust

<% } %>

<% for fd in self.fn_deps { %>
  <%- fd.name.open_namespace() %>
    <% let CppFnSig { rust_link_name, inputs, output } = &fd.sig; %>
    inline <%- output %> <%- fd.name.name() %>(
      <%- splat!(inputs, |n, ty|, "{ty} i{n}") %>
    ) noexcept {
      <%- output %> o{};
      <% for n in 0..inputs.len() { %> ::rust::__zngur_internal_assume_deinit(i<%- n %>); <% } %>
      <%- rust_link_name %> (
        <% if !inputs.is_empty() { %><%- splat!(inputs, |n, _ty|, "::rust::__zngur_internal_data_ptr(i{n})") %>,<% } %>
        ::rust::__zngur_internal_data_ptr(o)
      );
      <%- self.panic_handler() %>
      ::rust::__zngur_internal_assume_init(o);
      return o;
    }
  <%- fd.name.close_namespace() %>
<% } %>

namespace rust {
namespace exported_functions {

<% for func in self.exported_fn_defs { %>
  <%- func.sig.output %> <%- func.name %>(
    <%- splat!(&func.sig.inputs, |n, ty|, "{ty} i{n}") %>
  );
<% } %>

} // namespace exported_functions

<% for imp in self.exported_impls { %>
  <% let x = match &imp.tr { Some(x) => format!("{x}"), None => "::rust::Inherent".to_string() }; %>

  template<>
  class Impl< <%- imp.ty %>, <%- x %> > {
    public:
      <% for (name, sig) in &imp.methods { %>
        static <%- sig.output %> <%- name %>(
          <%- splat!(&sig.inputs, |n, ty|, "{ty} i{n}") %>
        );
      <% } %>
  };
<% } %>

} // namespace rust
