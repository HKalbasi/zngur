#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <csignal>
#include <array>
#include <iostream>
#include <functional>
#include <math.h>

<%= self.additional_includes %>

<% if let Some(symbols) = &self.panic_to_exception { %>
namespace rust {
    class Panic {};
}
extern "C" {
    uint8_t <%= symbols.detect_panic %>();
    void <%= symbols.take_panic %>();
}
<% } %>

#define zngur_dbg(x) (::rust::zngur_dbg_impl(__FILE__, __LINE__, #x, x))

namespace rust {
    template<typename T>
    uint8_t* __zngur_internal_data_ptr(const T& t) noexcept ;

    template<typename T>
    void __zngur_internal_assume_init(T& t) noexcept ;

    template<typename T>
    void __zngur_internal_assume_deinit(T& t) noexcept ;

    template<typename T>
    inline size_t __zngur_internal_size_of() noexcept ;

    template<typename T>
    inline void __zngur_internal_move_to_rust(uint8_t* dst, T& t) noexcept {
        memcpy(dst, ::rust::__zngur_internal_data_ptr(t), ::rust::__zngur_internal_size_of<T>());
        ::rust::__zngur_internal_assume_deinit(t);
    }

    template<typename T>
    inline T __zngur_internal_move_from_rust(uint8_t* src) noexcept {
        T t;
        ::rust::__zngur_internal_assume_init(t);
        memcpy(::rust::__zngur_internal_data_ptr(t), src, ::rust::__zngur_internal_size_of<T>());
        return t;
    }

    template<typename T>
    inline void __zngur_internal_check_init(const T&) noexcept {
    }

    class ZngurCppOpaqueOwnedObject {
        uint8_t* data;
        void (*destructor)(uint8_t*);

    public:
        template<typename T, typename... Args>
        inline static ZngurCppOpaqueOwnedObject build(Args&&... args) {
            ZngurCppOpaqueOwnedObject o;
            o.data = reinterpret_cast<uint8_t*>(new T(::std::forward<Args>(args)...));
            o.destructor = [](uint8_t* d) {
                delete reinterpret_cast<T*>(d);
            };
            return o;
        }

        template<typename T>
        inline T& as_cpp() {
            return *reinterpret_cast<T *>(data);
        }
    };

    template<typename T>
    struct Ref;

    template<typename T>
    struct RefMut;

    template<typename T, size_t OFFSET>
    struct FieldOwned {
        inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
    };

    template<typename T, size_t OFFSET>
    struct FieldRef {
        inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
    };

    template<typename T, size_t OFFSET>
    struct FieldRefMut {
        inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
    };

    template<typename... T>
    struct Tuple;

    using Unit = Tuple<>;

    template<typename T>
    struct ZngurPrettyPrinter;

    class Inherent;

    template<typename Type, typename Trait = Inherent>
    class Impl;

    template<typename T>
    T&& zngur_dbg_impl(const char* file_name, int line_number, const char* exp, T&& input) {
        ::std::cerr << "[" << file_name << ":" << line_number << "] " << exp << " = ";
        ZngurPrettyPrinter<typename ::std::remove_reference<T>::type>::print(input);
        return ::std::forward<T>(input);
    }

<% for ty in self.builtin_types() { %>
<% let needs_endif = ty.starts_with("int") || ty.starts_with("uint") || ty.starts_with("::size_t") || ty.starts_with("::double") || ty.starts_with("::float"); %>
<% if needs_endif { %>
#if defined(__APPLE__) || defined(__wasm__)
<% } %>

    template<>
    inline uint8_t* __zngur_internal_data_ptr< <%= ty %> >(const <%= ty %>& t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }

    template<>
    inline void __zngur_internal_assume_init< <%= ty %> >(<%= ty %>&) noexcept {}
    template<>
    inline void __zngur_internal_assume_deinit< <%= ty %> >(<%= ty %>&) noexcept {}

    template<>
    inline size_t __zngur_internal_size_of< <%= ty %> >() noexcept {
        return sizeof(<%= ty %>);
    }

    template<>
    inline uint8_t* __zngur_internal_data_ptr< <%= ty %>*>(<%= ty %>* const & t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }

    template<>
    inline void __zngur_internal_assume_init< <%= ty %>*>(<%= ty %>*&) noexcept {}
    template<>
    inline void __zngur_internal_assume_deinit< <%= ty %>*>(<%= ty %>*&) noexcept {}

    template<>
    inline uint8_t* __zngur_internal_data_ptr< <%= ty %> const*>(<%= ty %> const* const & t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }

    template<>
    inline void __zngur_internal_assume_init< <%= ty %> const*>(<%= ty %> const*&) noexcept {}
    template<>
    inline void __zngur_internal_assume_deinit< <%= ty %> const*>(<%= ty %> const*&) noexcept {}

    template<>
    struct Ref< <%= ty %> > {
        Ref() {
            data = 0;
        }
        Ref(const <%= ty %>& t) {
            data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
        }

         template<size_t OFFSET>
         Ref(const FieldOwned< <%= ty %>, OFFSET >& f) {
             data = reinterpret_cast<size_t>(&f) + OFFSET;
         }

         template<size_t OFFSET>
         Ref(const FieldRef< <%= ty %>, OFFSET >& f) {
             data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
         }

         template<size_t OFFSET>
         Ref(const FieldRefMut< <%= ty %>, OFFSET >& f) {
             data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
         }

        <%= ty %>& operator*() {
            return *reinterpret_cast< <%= ty %>*>(data);
        }
        private:
            size_t data;
        friend uint8_t* ::rust::__zngur_internal_data_ptr<Ref< <%= ty %> > >(const ::rust::Ref< <%= ty %> >& t) noexcept ;
        friend ::rust::ZngurPrettyPrinter< Ref< <%= ty %> > >;
    };

    template<>
    struct RefMut< <%= ty %> > {
        RefMut() {
            data = 0;
        }
        RefMut(<%= ty %>& t) {
            data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
        }

         template<size_t OFFSET>
         RefMut(const FieldOwned< <%= ty %>, OFFSET >& f) {
             data = reinterpret_cast<size_t>(&f) + OFFSET;
         }

         template<size_t OFFSET>
         RefMut(const FieldRefMut< <%= ty %>, OFFSET >& f) {
             data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
         }

        <%= ty %>& operator*() {
            return *reinterpret_cast< <%= ty %>*>(data);
        }
        private:
            size_t data;
        friend uint8_t* ::rust::__zngur_internal_data_ptr<RefMut< <%= ty %> > >(const ::rust::RefMut< <%= ty %> >& t) noexcept ;
        friend ::rust::ZngurPrettyPrinter< Ref< <%= ty %> > >;
    };

    <% let printable = ty.starts_with("int") || ty.starts_with("uint") || ty.starts_with("::size_t") || ty.starts_with("::double") || ty.starts_with("::float"); %>
    <% if printable { %>
    template<>
    struct ZngurPrettyPrinter< <%= ty %> > {
        static inline void print(<%= ty %> const& t) {
            ::std::cerr << t << ::std::endl;
        }
    };
    <% } %>

    <% if needs_endif { %>
#endif
<% } %>

<% } %>

} // namespace rust

extern "C" {
  <% for f in self.fn_deps { %>
    void <%= f.sig.rust_link_name %> (
      <% for n in 0..f.sig.inputs.len() { %>
        uint8_t* i<%= n %>,
      <% } %>
      uint8_t* o
    ) noexcept ;
  <% } %>

  <% for td in self.type_defs { %>
    <% /*TODO: This duplicates the logic above. It's not clear whether repetition is better or worse for understandability*/ %>
    <% for method in &td.methods { %>
      void <%= method.sig.rust_link_name %> (
        <% for n in 0..method.sig.inputs.len() { %>
          uint8_t* i<%= n %>,
        <% } %>
        uint8_t* o
      ) noexcept ;
    <% } %>

    <% for constructor in &td.constructors { %>
      void <%= constructor.rust_link_name %> (
        <% for n in 0..constructor.inputs.len() { %>
          uint8_t* i<%= n %>,
        <% } %>
        uint8_t* o
      ) noexcept ;
    <% } %>

    <% if let Some(cpp_value) = &td.cpp_value { %>
      ::rust::ZngurCppOpaqueOwnedObject* <%= cpp_value.0 %>(uint8_t*);
    <% } %>

    <% if let CppLayoutPolicy::HeapAllocated { size_fn, alloc_fn, free_fn } = &td.layout { %>
      size_t <%= size_fn %>();
      uint8_t* <%= alloc_fn %>();
      void <%= free_fn %>(uint8_t*);
    <% } %>

    <% for tr in &td.wellknown_traits { %>
      <% /* TODO: sailfish match is pretty bad. Raise an issue. */ %>
      <% if let ZngurWellknownTraitData::Debug { pretty_print, debug_print } = tr { %>
        void <%= pretty_print %>(uint8_t*);
        void <%= debug_print %>(uint8_t*);
      <% } else if let ZngurWellknownTraitData::Drop { drop_in_place } = tr { %>
        void <%= drop_in_place %>(uint8_t*);
      <% } else if let ZngurWellknownTraitData::Unsized | ZngurWellknownTraitData::Copy = tr { %>
        <% /* No output for Unsized and Copy traits */ %>
      <% } %>
    <% } %>

    <% for (_, td) in self.trait_defs { %>
      <% if let CppTraitDefinition::Fn { sig } = td { %>
        void <%= sig.rust_link_name %>(uint8_t* data, void destructor(uint8_t *),
                                       void call(uint8_t *,
                                          <% for n in 0..sig.inputs.len() { %> uint8_t *i<%= n %>, <% } %>uint8_t *o)
        );
      <% } else if let CppTraitDefinition::Normal { link_name, link_name_ref, .. } = td { %>
        void <%= link_name %>(uint8_t *data, void destructor(uint8_t *), uint8_t *o);
        void <%= link_name_ref %>(uint8_t *data, uint8_t *o);
      <% } %>
    <% } %>

  <% } %>

} // extern "C"

<% for td in self.type_defs { %>
  <%= td.ty.header() %>
<% } %>

<% for imp in self.exported_impls { %>
  <%= imp.ty.header() %>
  <% if let Some(tr) = &imp.tr { %>
    <%= tr.header() %>
  <% } %>
<% } %>

<% for (_, td) in self.trait_defs { %>
  <% if let CppTraitDefinition::Normal { as_ty, methods, .. } = td { %>
    <%= as_ty.path.open_namespace() %>
    <% if as_ty.generic_args.is_empty() { %>
      struct <%= as_ty.path.name() %> {
    <% } else { %>
      template <>
      struct <%= as_ty.path.name() %> < <%= as_ty.generic_args.iter().join(", ") %> > {
    <% } %>
      public:
          virtual ~<%= as_ty.path.name() %>() {};
          <% for method in methods { %>
            virtual <%= method.output %> <%= method.name %> (
              <%= method.inputs.iter().enumerate().map(|(n, x)| format!("{x} i{n}")).join(", ") %>
            ) = 0;
          <% } %>
      };
    <%= as_ty.path.close_namespace() %>
  <% } %>
<% } %>
