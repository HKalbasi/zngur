#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <csignal>
#include <array>
#include <iostream>
#include <functional>
#include <math.h>

{{ additional_includes }}

{%- if let Some(symbols) = panic_to_exception -%}
namespace rust {
    class Panic {};
}
extern "C" {
    uint8_t {{ symbols.detect_panic }}();
    void {{ symbols.take_panic }}();
}
{%- endif -%}

#define zngur_dbg(x) (::rust::zngur_dbg_impl(__FILE__, __LINE__, #x, x))

namespace rust {
    template<typename T>
    uint8_t* __zngur_internal_data_ptr(const T& t) noexcept ;

    template<typename T>
    void __zngur_internal_assume_init(T& t) noexcept ;

    template<typename T>
    void __zngur_internal_assume_deinit(T& t) noexcept ;

    template<typename T>
    inline size_t __zngur_internal_size_of() noexcept ;

    template<typename T>
    inline void __zngur_internal_move_to_rust(uint8_t* dst, T& t) noexcept {
        memcpy(dst, ::rust::__zngur_internal_data_ptr(t), ::rust::__zngur_internal_size_of<T>());
        ::rust::__zngur_internal_assume_deinit(t);
    }

    template<typename T>
    inline T __zngur_internal_move_from_rust(uint8_t* src) noexcept {
        T t;
        ::rust::__zngur_internal_assume_init(t);
        memcpy(::rust::__zngur_internal_data_ptr(t), src, ::rust::__zngur_internal_size_of<T>());
        return t;
    }

    template<typename T>
    inline void __zngur_internal_check_init(const T&) noexcept {
    }

    class ZngurCppOpaqueOwnedObject {
        uint8_t* data;
        void (*destructor)(uint8_t*);

    public:
        template<typename T, typename... Args>
        inline static ZngurCppOpaqueOwnedObject build(Args&&... args) {
            ZngurCppOpaqueOwnedObject o;
            o.data = reinterpret_cast<uint8_t*>(new T(::std::forward<Args>(args)...));
            o.destructor = [](uint8_t* d) {
                delete reinterpret_cast<T*>(d);
            };
            return o;
        }

        template<typename T>
        inline T& as_cpp() {
            return *reinterpret_cast<T *>(data);
        }
    };

    template<typename T>
    struct Ref;

    template<typename T>
    struct RefMut;

    template<typename T, size_t OFFSET>
    struct FieldOwned {
        inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
    };

    template<typename T, size_t OFFSET>
    struct FieldRef {
        inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
    };

    template<typename T, size_t OFFSET>
    struct FieldRefMut {
        inline operator T() const noexcept { return *::rust::Ref<T>(*this); }
    };

    template<typename... T>
    struct Tuple;

    using Unit = Tuple<>;

    template<typename T>
    struct ZngurPrettyPrinter;

    class Inherent;

    template<typename Type, typename Trait = Inherent>
    class Impl;

    template<typename T>
    T&& zngur_dbg_impl(const char* file_name, int line_number, const char* exp, T&& input) {
        ::std::cerr << "[" << file_name << ":" << line_number << "] " << exp << " = ";
        ZngurPrettyPrinter<typename ::std::remove_reference<T>::type>::print(input);
        return ::std::forward<T>(input);
    }

{%- for ty in builtin_types() -%}
{% let needs_endif = ty.starts_with("int") || ty.starts_with("uint") || ty.starts_with("::size_t") || ty.starts_with("::double") || ty.starts_with("::float") %}
{% if needs_endif %}
#if defined(__APPLE__) || defined(__wasm__)
{% endif %}

    template<>
    inline uint8_t* __zngur_internal_data_ptr< {{ ty }} >(const {{ ty }}& t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }

    template<>
    inline void __zngur_internal_assume_init< {{ ty }} >({{ ty }}&) noexcept {}
    template<>
    inline void __zngur_internal_assume_deinit< {{ ty }} >({{ ty }}&) noexcept {}

    template<>
    inline size_t __zngur_internal_size_of< {{ ty }} >() noexcept {
        return sizeof({{ ty }});
    }

    template<>
    inline uint8_t* __zngur_internal_data_ptr< {{ ty }}*>({{ ty }}* const & t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }

    template<>
    inline void __zngur_internal_assume_init< {{ ty }}*>({{ ty }}*&) noexcept {}
    template<>
    inline void __zngur_internal_assume_deinit< {{ ty }}*>({{ ty }}*&) noexcept {}

    template<>
    inline uint8_t* __zngur_internal_data_ptr< {{ ty }} const*>({{ ty }} const* const & t) noexcept {
        return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(&t));
    }

    template<>
    inline void __zngur_internal_assume_init< {{ ty }} const*>({{ ty }} const*&) noexcept {}
    template<>
    inline void __zngur_internal_assume_deinit< {{ ty }} const*>({{ ty }} const*&) noexcept {}

    template<>
    struct Ref< {{ ty }} > {
        Ref() {
            data = 0;
        }
        Ref(const {{ ty }}& t) {
            data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
        }

         template<size_t OFFSET>
         Ref(const FieldOwned< {{ ty }}, OFFSET >& f) {
             data = reinterpret_cast<size_t>(&f) + OFFSET;
         }

         template<size_t OFFSET>
         Ref(const FieldRef< {{ ty }}, OFFSET >& f) {
             data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
         }

         template<size_t OFFSET>
         Ref(const FieldRefMut< {{ ty }}, OFFSET >& f) {
             data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
         }

        {{ ty }}& operator*() {
            return *reinterpret_cast< {{ ty }}*>(data);
        }
        private:
            size_t data;
        friend uint8_t* ::rust::__zngur_internal_data_ptr<Ref< {{ ty }} > >(const ::rust::Ref< {{ ty }} >& t) noexcept ;
        friend ::rust::ZngurPrettyPrinter< Ref< {{ ty }} > >;
    };

    template<>
    struct RefMut< {{ ty }} > {
        RefMut() {
            data = 0;
        }
        RefMut({{ ty }}& t) {
            data = reinterpret_cast<size_t>(__zngur_internal_data_ptr(t));
        }

         template<size_t OFFSET>
         RefMut(const FieldOwned< {{ ty }}, OFFSET >& f) {
             data = reinterpret_cast<size_t>(&f) + OFFSET;
         }

         template<size_t OFFSET>
         RefMut(const FieldRefMut< {{ ty }}, OFFSET >& f) {
             data = *reinterpret_cast<const size_t*>(&f) + OFFSET;
         }

        {{ ty }}& operator*() {
            return *reinterpret_cast< {{ ty }}*>(data);
        }
        private:
            size_t data;
        friend uint8_t* ::rust::__zngur_internal_data_ptr<RefMut< {{ ty }} > >(const ::rust::RefMut< {{ ty }} >& t) noexcept ;
        friend ::rust::ZngurPrettyPrinter< Ref< {{ ty }} > >;
    };

    {% let printable = ty.starts_with("int") || ty.starts_with("uint") || ty.starts_with("::size_t") || ty.starts_with("::double") || ty.starts_with("::float") %}
    {% if printable %}
    template<>
    struct ZngurPrettyPrinter< {{ ty }} > {
        static inline void print({{ ty }} const& t) {
            ::std::cerr << t << ::std::endl;
        }
    };
    {% endif %}

    {% if needs_endif %}
#endif
{% endif %}

{%- endfor -%}

} // namespace rust
