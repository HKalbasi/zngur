Test dbg works for Ref and RefMut -- started
[main.cpp:11] v1 = "foo"
[main.cpp:13] v2 = "foo"
[main.cpp:15] v3 = "foo"
[main.cpp:16] v2 = "foo"
[main.cpp:17] v4 = "foo"
[main.cpp:19] v5 = "foo"
[main.cpp:20] "bar"_rs = "bar"
[main.cpp:21] v4 = "foobar"
Test dbg works for Ref and RefMut -- finished

Test fields and constructor work -- started
[main.cpp:31] v1 = Foo {
    field1: 1,
    field2: "bar",
}
[main.cpp:32] v1.field2 = "bar"
[main.cpp:33] v1.field2.len() = 3
[main.cpp:35] v1 = Foo {
    field1: 1,
    field2: "barbaz",
}
[main.cpp:39] v2 = (
    "kkk",
    Foo {
        field1: 1,
        field2: "barbaz",
    },
)
[main.cpp:40] v2.f0 = "kkk"
[main.cpp:41] v2.f1 = Foo {
    field1: 1,
    field2: "barbaz",
}
[main.cpp:42] v2.f1.field2 = "barbaz"
[main.cpp:46] v3.f0 = "kkk"
[main.cpp:47] v3.f1 = Foo {
    field1: 1,
    field2: "barbazxxx",
}
[main.cpp:48] v3.f1.field2 = "barbazxxx"
[main.cpp:51] v3.f1.field2.len() = 9
[main.cpp:55] v4.f0 = "kkk"
[main.cpp:56] v4.f1 = Foo {
    field1: 1,
    field2: "barbazxxx",
}
[main.cpp:57] v4.f1.field2 = "barbazxxx"
[main.cpp:59] v4.f1.field2.len() = 12
Test fields and constructor work -- finished

Test Field* underlying conversions -- started
[main.cpp:71] v0 = 42
[main.cpp:75] v1 = "hi"
[main.cpp:79] sref.len() = 2
[main.cpp:82] int32_t(pref.f0) = 42
[main.cpp:83] pref.f1.len() = 2
[main.cpp:86] int32_t(pmut.f0) = 42
[main.cpp:88] pmut.f1.len() = 3
Test Field* underlying conversions -- finished

Test floats -- started
[main.cpp:98] *r1 = 12.3
[main.cpp:100] v1 = 12.3
[main.cpp:105] fvec = [
    42.24,
    147.0,
]
[main.cpp:106] fvec.get(0) = Some(
    42.24,
)
[main.cpp:107] fvec.get(2) = None
[main.cpp:108] *fvec.get(1).unwrap() = 147
[main.cpp:110] fvec = [
    42.24,
    5.43,
]
Test floats -- finished

Test dyn Fn() with multiple arguments -- started
scope passed to dyn Fn -- started
Inner function called
scope passed to dyn Fn -- finished

End of call_dyn_fn_multi_args
Test dyn Fn() with multiple arguments -- finished

Test Ref<Ref<T>> -- started
[main.cpp:131] strvec = [
    "a str",
    "foobar",
    "a third str",
]
[main.cpp:132] strvec.get(0) = Some(
    "a str",
)
[main.cpp:133] strvec.get(2) = Some(
    "a third str",
)
[main.cpp:134] *strvec.get(1).unwrap() = "foobar"
[main.cpp:136] strvec = [
    "a str",
    "flip flop",
    "a third str",
]
Test Ref<Ref<T>> -- finished

Test zero-sized type -- started
Method call on ZST
[main.cpp:143] zst = ZeroSizedType
Test zero-sized type -- finished

Test nested Ref<T> where T is #heap_allocated and auto field offsets -- started
[main.cpp:158] a = TypeA {
    foo: 10,
    bar: FieldTypeA {
        fizz: FieldTypeC {
            buzz_1: 20,
            buzz_2: 30,
            buzz_3: 40,
        },
    },
    baz: FieldTypeB {
        fizz: FieldTypeC {
            buzz_1: 50,
            buzz_2: 60,
            buzz_3: 70,
        },
    },
}
[main.cpp:159] ::rust::Ref(a.foo) = 10
[main.cpp:160] ::rust::Ref(a.bar.fizz.buzz_2) = 30
[main.cpp:161] ::rust::RefMut(a.baz.fizz.buzz_3) = 70
[main.cpp:164] ::rust::Ref(a_fa_fizz.buzz_1) = 20
[main.cpp:166] ::rust::Ref(a_fb_fizz.buzz_2) = 60
[main.cpp:177] b = TypeB {
    foo: 100,
    bar: FieldTypeA {
        fizz: FieldTypeC {
            buzz_1: 200,
            buzz_2: 300,
            buzz_3: 400,
        },
    },
    baz: FieldTypeB {
        fizz: FieldTypeC {
            buzz_1: 500,
            buzz_2: 600,
            buzz_3: 700,
        },
    },
}
[main.cpp:178] ::rust::Ref<int32_t>(b.foo) = 100
[main.cpp:179] ::rust::Ref<int32_t>(b.bar.fizz.buzz_2) = 300
[main.cpp:180] ::rust::RefMut<int32_t>(b.baz.fizz.buzz_3) = 700
[main.cpp:183] ::rust::Ref<int32_t>(b_fa_fizz.buzz_1) = 200
[main.cpp:185] ::rust::Ref<int32_t>(b_fb_fizz.buzz_2) = 600
[main.cpp:190] fa = FieldTypeA {
    fizz: FieldTypeC {
        buzz_1: 21,
        buzz_2: 31,
        buzz_3: 41,
    },
}
[main.cpp:191] ::rust::Ref<int32_t>(fa.fizz.buzz_1) = 21
[main.cpp:192] ::rust::Ref<int32_t>(fa.fizz.buzz_3) = 41
[main.cpp:197] fa = FieldTypeA {
    fizz: FieldTypeC {
        buzz_1: 21,
        buzz_2: 31,
        buzz_3: 41,
    },
}
[main.cpp:198] ::rust::Ref<int32_t>(fb.fizz.buzz_2) = 61
[main.cpp:199] ::rust::Ref<int32_t>(fb.fizz.buzz_3) = 71
Test nested Ref<T> where T is #heap_allocated and auto field offsets -- finished

Test #layout_conservative -- started
[main.cpp:208] c_layout = ConservativeLayoutType {
    field1: 3.14159,
    field2: 42,
    field3: "A string at some unknown offset",
}
Rust( size = 32 , align = 8 )
c++( size = 48 , align = 8 )
[main.cpp:220] layouts = [
    ConservativeLayoutType {
        field1: 3.14159,
        field2: 42,
        field3: "A string at some unknown offset",
    },
    ConservativeLayoutType {
        field1: 2.71828,
        field2: 1000,
        field3: "Another test string",
    },
]
[main.cpp:221] layouts.get(0) = Some(
    ConservativeLayoutType {
        field1: 3.14159,
        field2: 42,
        field3: "A string at some unknown offset",
    },
)
[main.cpp:222] layouts.get(1) = Some(
    ConservativeLayoutType {
        field1: 2.71828,
        field2: 1000,
        field3: "Another test string",
    },
)
[main.cpp:223] layouts.get(1).unwrap() = ConservativeLayoutType {
    field1: 2.71828,
    field2: 1000,
    field3: "Another test string",
}
[main.cpp:225] layouts = [
    ConservativeLayoutType {
        field1: 3.14159,
        field2: 42,
        field3: "A string at some unknown offset",
    },
    ConservativeLayoutType {
        field1: 2.71828,
        field2: 10,
        field3: "Another test string",
    },
]
Test #layout_conservative -- finished

